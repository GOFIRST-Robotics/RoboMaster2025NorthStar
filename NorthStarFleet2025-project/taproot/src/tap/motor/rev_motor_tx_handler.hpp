/*****************************************************************************/
/********** !!! WARNING: CODE GENERATED BY TAPROOT. DO NOT EDIT !!! **********/
/*****************************************************************************/

/*
 * Copyright (c) 2020-2021 Advanced Robotics at the University of Washington <robomstr@uw.edu>
 *
 * This file is part of Taproot.
 *
 * Taproot is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Taproot is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Taproot.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef TAPROOT_REV_MOTOR_TX_HANDLER_HPP_
#define TAPROOT_REV_MOTOR_TX_HANDLER_HPP_

#include <limits.h>

#include "tap/util_macros.hpp"

#include "rev_motor.hpp"

namespace tap
{
class Drivers;
}

namespace tap::motor
{
// /**
//  * Converts the dji MotorId to a uint32_t.
//  * @param[in] id Some CAN MotorId
//  * @return id normalized to be around [0, DJI_MOTORS_PER_CAN), or some value >= DJI_MOTORS_PER_CAN
//  * if the id is out of bounds
//  */
//  #define REV_MOTOR_TO_NORMALIZED_ID(id)                                                  \
//      static_cast<uint32_t>(                                                              \
//          (id < tap::motor::REV_MOTOR1) ? (tap::motor::RevMotorTxHandler::REV_MOTORS_PER_CAN) \
//                                    : (id - tap::motor::MOTOR1))

// /**
//  * Converts the dji MotorId to a uint32_t.
//  * @param[in] idx Some index, a motor id index normalized between [0, DJI_MOTORS_PER_CAN)
//  * @return idx, converted to a MotorId
//  */
//  #define NORMALIZED_ID_TO_REV_MOTOR(idx) \
//      static_cast<tap::motor::REVMotorId>(idx + static_cast<int32_t>(tap::motor::REVMotorId::MOTOR1))

/**
 * Uses modm can interface to send CAN packets to `RevMotor`'s connected to the two CAN buses.
 *
 * To use this class properly, declare a motor somewhere, then call the initialize method, which
 * allows one to start interacting with a motor connected via CAN bus. When the motor's `initialize`
 * function is called, this object's `addMotorToManager` function is called and the motor is ready
 * to have its control information sent to the motor on the bus.
 *
 * To send messages, call this class's `encodeAndSendCanData` function.
 */
class RevMotorTxHandler
{
public:

    enum class APICommand : uint16_t
    {
    ClearFaults     = (6 << 4) | 14,
    FactoryDefaults = (7 << 4) | 4,
    FactoryReset    = (7 << 4) | 5,
    Identify        = (7 << 4) | 6,
    Heartbeat       = (11 << 4) | 2,
    BurnFlash       = (63 << 4) | 2,
    FirmwareVersion = (9 << 4) | 8,

    Setpoint        = (0 << 4) | 1,
    DutyCycle       = (0 << 4) | 2,
    Velocity        = (1 << 4) | 2,
    SmartVelocity   = (1 << 4) | 3,
    Position        = (3 << 4) | 2,
    Voltage         = (4 << 4) | 2,
    Current         = (4 << 4) | 3,
    SmartMotion     = (5 << 4) | 2,

    Period0         = (6 << 4) | 0,
    Period1         = (6 << 4) | 1,
    Period2         = (6 << 4) | 2,
    Period3         = (6 << 4) | 3,
    Period4         = (6 << 4) | 4
    };

    enum class Parameter : uint32_t
    {
        kInputMode = 1,
        kMotorType = 2,
        kCommAdvance = 3,
        kSensorType = 4,
        kCtrlType = 5,
        kIdleMode = 6,
        kInputDeadband = 7,
        kFeedbackSensorPID0 = 8,
        kFeedbackSensorPID1 = 9,
        kPolePairs = 10,
        kCurrentChop = 11,
        kCurrentChopCycles = 12,
        kP_0 = 13,
        kI_0 = 14,
        kD_0 = 15,
        kF_0 = 16,
        kIZone_0 = 17,
        kDFilter_0 = 18,
        kOutputMin_0 = 19,
        kOutputMax_0 = 20,
        kP_1 = 21,
        kI_1 = 22,
        kD_1 = 23,
        kF_1 = 24,
        kIZone_1 = 25,
        kDFilter_1 = 26,
        kOutputMin_1 = 27,
        kOutputMax_1 = 28,
        kP_2 = 29,
        kI_2 = 30,
        kD_2 = 31,
        kF_2 = 32,
        kIZone_2 = 33,
        kDFilter_2 = 34,
        kOutputMin_2 = 35,
        kOutputMax_2 = 36,
        kP_3 = 37,
        kI_3 = 38,
        kD_3 = 39,
        kF_3 = 40,
        kIZone_3 = 41,
        kDFilter_3 = 42,
        kOutputMin_3 = 43,
        kOutputMax_3 = 44,
        kInverted = 45,
        kOutputRatio = 46,
        kSerialNumberLow = 47,
        kSerialNumberMid = 48,
        kSerialNumberHigh = 49,
        kLimitSwitchFwdPolarity = 50,
        kLimitSwitchRevPolarity = 51,
        kHardLimitFwdEn = 52,
        kHardLimitRevEn = 53,
        kSoftLimitFwdEn = 54,
        kSoftLimitRevEn = 55,
        kRampRate = 56,
        kFollowerID = 57,
        kFollowerConfig = 58,
        kSmartCurrentStallLimit = 59,
        kSmartCurrentFreeLimit = 60,
        kSmartCurrentConfig = 61,
        kMotorKv = 63,
        kMotorR = 64,
        kMotorL = 65,
        kEncoderCountsPerRev = 69,
        kEncoderAverageDepth = 70,
        kEncoderSampleDelta = 71,
        kEncoderInverted = 72,
        kClosedLoopVoltageMode = 74,
        kCompensatedNominalVoltage = 75,
        kSmartMotionMaxVelocity_0 = 76,
        kSmartMotionMaxAccel_0 = 77,
        kSmartMotionMinVelOutput_0 = 78,
        kSmartMotionAllowedClosedLoopError_0 = 79,
        kSmartMotionAccelStrategy_0 = 80,
        kSmartMotionMaxVelocity_1 = 81,
        kSmartMotionMaxAccel_1 = 82,
        kSmartMotionMinVelOutput_1 = 83,
        kSmartMotionAllowedClosedLoopError_1 = 84,
        kSmartMotionAccelStrategy_1 = 85,
        kSmartMotionMaxVelocity_2 = 86,
        kSmartMotionMaxAccel_2 = 87,
        kSmartMotionMinVelOutput_2 = 88,
        kSmartMotionAllowedClosedLoopError_2 = 89,
        kSmartMotionAccelStrategy_2 = 90,
        kSmartMotionMaxVelocity_3 = 91,
        kSmartMotionMaxAccel_3 = 92,
        kSmartMotionMinVelOutput_3 = 93,
        kSmartMotionAllowedClosedLoopError_3 = 94,
        kSmartMotionAccelStrategy_3 = 95,
        kIMaxAccum_0 = 96,
        kSlot3Placeholder1_0 = 97,
        kSlot3Placeholder2_0 = 98,
        kSlot3Placeholder3_0 = 99,
        kIMaxAccum_1 = 100,
        kSlot3Placeholder1_1 = 101,
        kSlot3Placeholder2_1 = 102,
        kSlot3Placeholder3_1 = 103,
        kIMaxAccum_2 = 104,
        kSlot3Placeholder1_2 = 105,
        kSlot3Placeholder2_2 = 106,
        kSlot3Placeholder3_2 = 107,
        kIMaxAccum_3 = 108,
        kSlot3Placeholder1_3 = 109,
        kSlot3Placeholder2_3 = 110,
        kSlot3Placeholder3_3 = 111,
        kPositionConversionFactor = 112,
        kVelocityConversionFactor = 113,
        kClosedLoopRampRate = 114,
        kSoftLimitFwd = 115,
        kSoftLimitRev = 116,
        kAnalogPositionConversion = 119,
        kAnalogVelocityConversion = 120,
        kAnalogAverageDepth = 121,
        kAnalogSensorMode = 122,
        kAnalogInverted = 123,
        kAnalogSampleDelta = 124,
        kDataPortConfig = 127,
        kAltEncoderCountsPerRev = 128,
        kAltEncoderAverageDepth = 129,
        kAltEncoderSampleDelta = 130,
        kAltEncoderInverted = 131,
        kAltEncoderPositionFactor = 132,
        kAltEncoderVelocityFactor = 133,
        kHallSensorSampleRate = 136,
        kHallSensorAverageDepth = 137,
        kDutyCyclePositionFactor = 139,
        kDutyCycleVelocityFactor = 140,
        kDutyCycleInverted = 141,
        kDutyCycleAverageDepth = 143,
        kPositionPIDWrapEnable = 149,
        kPositionPIDMinInput = 150,
        kPositionPIDMaxInput = 151,
        kDutyCyclePrescalar = 153,
        kDutyCycleZeroOffset = 154
    };



    
    /** Number of motors on each CAN bus. */
    static constexpr int REV_MOTORS_PER_CAN = 8;
    /** CAN message length of each motor control message. */
    static constexpr int CAN_REV_MESSAGE_SEND_LENGTH = 8;
    // /** CAN message identifier for "low" segment (low 4 CAN motor IDs) of control message. */
    // static constexpr uint32_t CAN_DJI_LOW_IDENTIFIER = 0X200;
    // /** CAN message identifier for "high" segment (high 4 CAN motor IDs) of control message. */
    // static constexpr uint32_t CAN_DJI_HIGH_IDENTIFIER = 0X1FF;

    RevMotorTxHandler(Drivers* drivers) : drivers(drivers) {}
    // mockable ~RevMotorTxHandler() = default;
    DISALLOW_COPY_AND_ASSIGN(RevMotorTxHandler)

    /**
     * Adds the motor to the manager so that it can receive motor messages from the CAN bus. If
     * there is already a motor with the same ID in the manager, the program will abort
     */
    void addMotorToManager(RevMotor* motor);

    /**
     * Sends motor commands across the CAN bus. Sends up to 4 messages (2 per CAN bus), though it
     * may send less depending on which motors have been registered with the motor manager. Each
     * messages encodes motor controller command information for up to 4 motors.
     */
    void encodeAndSendCanData();

    /**
     * Removes the motor from the motor manager.
     */
    void removeFromMotorManager(const RevMotor& motor);

    RevMotor const* getCan1Motor(REVMotorId motorId);

    RevMotor const* getCan2Motor(REVMotorId motorId);

private:
    Drivers* drivers;

    RevMotor* can1MotorStore[REV_MOTORS_PER_CAN] = {0};
    RevMotor* can2MotorStore[REV_MOTORS_PER_CAN] = {0};

    void addMotorToManager(RevMotor** canMotorStore, RevMotor* const motor);

    void removeFromMotorManager(const RevMotor& motor, RevMotor** motorStore);













    /**
     * calculates the 29 bit ID for the REV Spark max motor controller. The basis for this is that in the
     * id is the control mode with some 28 bit number for a specific control mode like voltage or setpoint.
     * there is then an operation done to merge the devices CAN ID with the Messgae ID to create a message for
     * a specific motor controller
     */
    modm::can::Message createRevCanControlMessage(APICommand cmd, const RevMotor* motor);
    modm::can::Message createRevCanParameterMessage(Parameter param, const RevMotor* motor);

    uint8_t GetAPIClass(APICommand cmd) const;
    uint8_t GetAPIIndex(APICommand cmd) const;


    uint32_t CreateArbitrationControlId(APICommand cmd, const RevMotor* motor) const;
    uint32_t CreateArbitrationParameterId(Parameter param, const RevMotor* motor) const;


    void serializeRevMotorHeartBeat(modm::can::Message* message);

};

}  // namespace tap::motor

#endif  // TAPROOT_DJI_MOTOR_TX_HANDLER_HPP_
