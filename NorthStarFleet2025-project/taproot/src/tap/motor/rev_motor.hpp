/*****************************************************************************/
/********** !!! WARNING: CODE GENERATED BY TAPROOT. DO NOT EDIT !!! **********/
/*****************************************************************************/

/*
 * Copyright (c) 2020-2021 Advanced Robotics at the University of Washington <robomstr@uw.edu>
 *
 * This file is part of Taproot.
 *
 * Taproot is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Taproot is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Taproot.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef TAPROOT_REV_MOTOR_HPP_
#define TAPROOT_REV_MOTOR_HPP_

#include <string>

#include "tap/architecture/timeout.hpp"
#include "tap/communication/can/can_rx_listener.hpp"

#include "motor_interface.hpp"

namespace tap::motor
{
/**
 * CAN IDs for the feedback messages sent by DJI motor controllers. Motor `i` in the set
 * {1, 2,...,8} sends feedback data with in a CAN message with ID 0x200 + `i`.
 * for declaring a new motor, must be one of these motor
 * identifiers
 */
enum REVMotorId : uint32_t
{
    REV_MOTOR1 = 0x001,
    REV_MOTOR2 = 0x002,
    REV_MOTOR3 = 0x003,
    REV_MOTOR4 = 0x004,
    REV_MOTOR5 = 0x005,
    REV_MOTOR6 = 0x006,
    REV_MOTOR7 = 0x007,
    REV_MOTOR8 = 0x008,
};

enum class APICommand : uint16_t
{
    ClearFaults     = (6 << 4) | 14,
    FactoryDefaults = (7 << 4) | 4,
    FactoryReset    = (7 << 4) | 5,
    Identify        = (7 << 4) | 6,
    Heartbeat       = (11 << 4) | 2,
    BurnFlash       = (63 << 4) | 2,
    FirmwareVersion = (9 << 4) | 8,

    Setpoint        = (0 << 4) | 1,
    DutyCycle       = (0 << 4) | 2,
    Velocity        = (1 << 4) | 2,
    SmartVelocity   = (1 << 4) | 3,
    Position        = (3 << 4) | 2,
    Voltage         = (4 << 4) | 2,
    Current         = (4 << 4) | 3,
    SmartMotion     = (5 << 4) | 2,

    Period0         = (6 << 4) | 0,
    Period1         = (6 << 4) | 1,
    Period2         = (6 << 4) | 2,
    Period3         = (6 << 4) | 3,
    Period4         = (6 << 4) | 4
};

/**
 * A class designed to interface with DJI brand motors and motor controllers over CAN.
 * This includes the C610 and C620 motor controllers and the GM6020 motor (that has a
 * built-in motor controller).
 *
 * @note: the default positive rotation direction (i.e.: when `this->isMotorInverted()
 *      == false`) is counter clockwise when looking at the shaft from the side opposite
 *      the motor. This is specified in the C620 user manual (page 18).
 *
 * DJI motor encoders store a consistent encoding for a given angle across power-cycles.
 * This means the encoder angle reported by the motor can have meaning if the encoding
 * for an angle is unique as it is for the GM6020s. However for geared motors like the
 * M3508 where a full encoder revolution does not correspond 1:1 to a shaft revolution,
 * it is impossible to know the orientation of the shaft given just the encoder value.
 *
 * Extends the CanRxListener class to attach a message handler for feedback data from the
 * motor to the CAN Rx dispatch handler.
 *
 * @note Currently there is no error handling for using a motor without having it be properly
 * initialize. You must call the `initialize` function in order for this class to work properly.
 */
class RevMotor : public can::CanRxListener
{
public:
    // 0 - 8191 for dji motors
    // static constexpr uint16_t ENC_RESOLUTION = 42;

    /**
     * @param drivers a pointer to the drivers struct
     * @param desMotorIdentifier the ID of this motor controller
     * @param motorCanBus the CAN bus the motor is on
     * @param isInverted if `false` the positive rotation direction of the shaft is
     *      counter-clockwise when looking at the shaft from the side opposite the motor.
     *      If `true` then the positive rotation direction will be clockwise.
     * @param name a name to associate with the motor for use in the motor menu
     * @param encoderWrapped the starting encoderValue to store for this motor.
     *      Will be overwritten by the first reported encoder value from the motor
     * @param encoderRevolutions the starting number of encoder revolutions to store.
     *      See comment for RevMotor::encoderRevolutions for more details.
     */
    RevMotor(
        Drivers* drivers,
        REVMotorId desMotorIdentifier,
        tap::can::CanBus motorCanBus,
        bool isInverted,
        const char* name
        // uint16_t encoderWrapped = ENC_RESOLUTION / 2,
        // int64_t encoderRevolutions = 0
        );

    mockable ~RevMotor();

    void initialize();

    DISALLOW_COPY_AND_ASSIGN(RevMotor)

    // /**
    //  * Overrides virtual method in the can class, called every time a message with the
    //  * CAN message id this class is attached to is received by the can receive handler.
    //  * Parses the data in the message and updates this class's fields accordingly.
    //  *
    //  * @param[in] message the message to be processed.
    //  */
    void processMessage(const modm::can::Message& message);



    /**
     * Serializes send data and deposits it in a message to be sent.
     */
    mockable void serializeCanSendData(modm::can::Message* txMessage) const;

    /**
     * @return the raw `desiredOutput` value which will be sent to the motor controller
     *      (specified via `setDesiredOutput()`)
     */

    mockable uint32_t getMotorIdentifier() const;

    mockable bool isMotorInverted() const { return motorInverted; };

    mockable tap::can::CanBus getCanBus() const;

    mockable const char* getName() const;


    void setTargetVoltage(float targetVoltage);












    /**
     * Control modes available for RevMotor operation
     */
    enum class ControlMode
    {
        DUTY_CYCLE,     // Direct duty cycle control (0.0 to 1.0)
        VELOCITY,       // Velocity control in RPM
        POSITION,       // Position control in rotations
        VOLTAGE,        // Voltage control in volts
        CURRENT,        // Current control in amps
        SMART_MOTION,   // Smart motion with acceleration and velocity limits
        SMART_VELOCITY  // Smart velocity with acceleration limits
    };

    APICommand controlModeToAPI(ControlMode mode);

    /**
     * Set the control mode for this motor
     * @param mode The desired control mode
     */
    void setControlMode(ControlMode mode);

    /**
     * Get the current control mode for this motor
     * @return The active control mode
     */
    ControlMode getControlMode() const;

    /**
     * Set the control value based on the current control mode
     * @param value The control value in appropriate units for the current mode
     */
    void setControlValue(float value);

    /**
     * Get the current control value
     * @return The control value in the units of the current mode
     */
    float getControlValue() const;

private:

    const char* motorName;

    Drivers* drivers;

    uint32_t motorIdentifier;

    tap::can::CanBus motorCanBus;

    int16_t desiredOutput;

    float dutyCycle;

    float voltage;

    float current;

    float velocity;

    float position;

    float targetVoltage;

    bool motorInverted;




    ControlMode currentControlMode = ControlMode::VOLTAGE;
    float controlValue = 0.0f;


};

}  // namespace tap::motor

#endif  // TAPROOT_DJI_MOTOR_HPP_
